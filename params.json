{"name":"Xsockets.net-4.0","tagline":"Super duper real-time framework","body":"Rev. Beta-2\r\n\r\n#Also available on GitHub Pages\r\n[http://xsockets.github.io/XSockets.NET-4.0/][1]\r\n\r\n#Do you want to try the 4.0 beta?\r\nSend an email to contact@xsockets.net and we will provide you with information on how to get started.\r\n\r\n#XSockets.NET 4 - Introduction\r\n\r\n## What is it?\r\nXSockets.NET is a real-time messaging system that allows communication between any device that has TCP/IP. The server can be hosted anywhere (.NET/Mono) and the clients cover every major browser + C#, VB.NET, Android, iOS, NETMF. And it is very easy to connect anything else that has a TCP/IP stack.\r\n\r\n***In short terms: RealTime, InternetOfThings and WebRTC in a single framework!***\r\n\r\n##Who uses it?\r\n\r\n    TODO: Add images here\r\n\r\n----------\r\n\r\n## Getting started with real-time communication\r\n### 1. Start a server\r\n\r\n    using (var container = Composable.GetExport<IXSocketServerContainer>())\r\n    {\r\n        container.Start();\r\n        Console.ReadLine();\r\n    }\r\n    \r\n### 2. Create a client and listen for \"MyMessage\"\r\n\r\nJavaScript\r\n\r\n    var conn = new XSockets.WebSocket('ws://127.0.0.1',['generic']);\r\n    conn.controller('generic').mymessage = function(data){\r\n        alert(data.Text);\r\n    };\r\n\r\nC#\r\n\r\n    var conn = new XSocketClient(\"ws://127.0.0.1:4502\", \"http://localhost\",\"generic\");\r\n    conn.Open();\r\n    conn.Controller(\"generic\").On(\"mymessage\", data => Console.WriteLine(data.Text));\r\n\r\n### 3. Send message\r\n\r\nJavaScript\r\n\r\n    conn.controller('generic').invoke('mymessage',{Text:'Hello JS RealTime'});\r\n    \r\nC#\r\n\r\n    c.Controller(\"generic\").Invoke(\"mymessage\",new {Text = \"Hello C# RealTime\"});\r\n\r\n### 4. What's next?\r\n#### JavaScript/C# Client API\r\nLearn to...\r\n - Use Pub/Sub or RPC\r\n - Use WebRTC for Video/Audio communication without plugins (JavaScript only)\r\n\r\n#### Server\r\nCreate...\r\n - Powerful server-side controllers\r\n - Custom pipeline\r\n - Interceptors (for messages, connections and errors)\r\n - Protocol-plugins (for connecting other things, devices, languages)\r\n - Clients in .NET, NodeJS, C, Perl, Raw sockets or whatever you feel like connecting!\r\n\r\n----------\r\n\r\n## Installing XSockets.NET\r\nXSockets.NET is distributed through nuget.org and chocolatey.org. From Chocolatey you install our Windows Service and on Nuget we have all our packages for development. You can read more about all the packages after the installation samples.\r\n\r\n### Install into a Self-Hosted application\r\nIn the nuget Package Manager Console run the command below to install the server.\r\n\r\n`PM> Install-Package XSockets.Server`\r\n####Start the server\r\n\r\nInside of the Main method start the server with the code below.\r\n\r\n    using XSockets.Core.Common.Socket;\r\n    using XSockets.Plugin.Framework;\r\n    using (var container = Composable.GetExport<IXSocketServerContainer>())\r\n    {\r\n        server.StartServers();\r\n        Console.WriteLine(\"Started, hit enter to quit\");\r\n        Console.ReadLine();\r\n    }\r\n\r\n####Install into OWIN\r\nOpen up the Package Manager Console and install the server\r\n\r\n`PM> Install-Package XSockets.Owin.Host`\r\n\r\n####How to register XSockets Middleware\r\nUseXSockets is an extension method for the OwinExtensions class.\r\n\r\n    using Microsoft.Owin;\r\n    using Owin;\r\n    using XSockets.Owin.Host;\r\n\r\n    [assembly: OwinStartupAttribute(typeof(MyApplication.Startup))]\r\n    namespace MyApplication\r\n    {\r\n        public partial class Startup\r\n        {\r\n            public void Configuration(IAppBuilder app)\r\n            {           \r\n                app.UseXSockets(true);       \r\n            }\r\n        }\r\n    }\r\n    \r\nSo basically just call the UseXSockets extension from where you have your StartUp class for OWIN.\r\n\r\n##Supported Platforms\r\n###Server system requirements\r\n\r\nSince XSockets.NET is built to run on both .NET and Mono the server can be hosted pretty much anywhere.\r\n\r\n###Client system requirements\r\n\r\nXSockets can be used from any client that has TCP/IP, and since XSockets.NET supports cross-protocol communication it is very easy to add new clients and protocols.\r\n\r\nThe XSockets.NET team has built a few client libraries to make life easier for our developers. All client libraries is using full-duplex/bi-directional communication.\r\n\r\n    Language    Requirements\r\n    C#          .NET 3.5, 4.0+\r\n    iOS         .NET 4.0+ (MonoTouch)\r\n    Android     .NET 4.0+ (MonoDroid)\r\n    NETMF       4.2, 4.3\r\n    JavaScript  Browser with websockets (there is a fallback for IE 9 & IE 8)\r\n\r\n###Communication - How it works\r\n\r\nThe architecture for XSockets.NET is simple yet powerful. Each client connects to a protocol, the protocol will then allow communication over n controllers. So you can multiplex over several controller on one connection. This architecture enables communication cross-protocol as well as cross-controller.\r\n\r\nDifferent clients have different capabilities, browsers for example have the RFC6455 (websockets) protocol implemented, but other things devices might talk a protocol that you have created. Since XSockets allows “cross-protocol communication” all connected clients can communicate with each other very easily.\r\n\r\n####Basic architecture\r\n![XSockets basic architecture][2]\r\n\r\nThe red clients are clients libraries written by XSockets.NET and the blue clients are examples of what we have easily connected with custom protocols.\r\n\r\nYou may also notice that XSockets enables not only cross-protocol communication, but also cross-controller communication so that you can call a method on another controller. Or even send data to client on another controller with a single line of code.\r\n\r\n----------\r\n\r\n#XSockets.NET 4 - Documentation\r\n\r\n##Server API Guide\r\n###How to create and use Controller classes\r\nTo create a `Controller`, create a class that derives from `XSockets.Core.XSocket.XSocketController`. The following example shows a simple `Controller` class for a chat application.\r\n\r\n    public class Chat : XSocketController\r\n    {\r\n        public void ChatMessage(string message)\r\n        {\r\n            this.InvokeToAll(message,\"chatmessage\");\r\n        }\r\n    }\r\n\r\nIn this example, a connected client can call the ChatMessage method, and when it does, the data received is broadcasted (RPC) to all clients connected to the `Controller`.\r\n\r\n**Give the controller an Alias**\r\n\r\nIf you want to specify a different name for clients to use, add the `XSocketsMetadata` attribute and set the `Alias` to the name you want for the controller. You might wanna do this is you have long and complex names for controller on the server.\r\n\r\nServer\r\n\r\n    [XSocketMetadata(PluginAlias = \"Chat\")]\r\n    public class MyToLongAndComplexClassNameForTheChat : XSocketController\r\n    \r\nAnd then you can connect using the `Alias` as shown below.\r\n    \r\nClient - JavaScript\r\n\r\n    var conn = new XSockets.WebSocket('ws://127.0.0.1:4502',['chat']);\r\n\r\nClient - C#\r\n\r\n    var conn = new XSocketsClient(\"ws://127.0.0.1:4502\",\"http://localhost\",\"chat\");\r\n\r\n####Controller object lifetime\r\n\r\nYou don't instantiate the `Controller` class or call its methods from your own code on the server. This is all done for you by the XSockets.NET plugin framework. XSockets.NET creates a new instance of your Controller the first time you use it on you connection. The `Controller` will live in memory for as long as the client is connected to it. This provides the possibility to have state on the controllers which is the most important feature when working with real-time frameworks.\r\n\r\nBecause the instances of the 'Controller' class ARE transient, you can use them to maintain state from one method call to the next. Each time the server receives a method call from the client, it will be the same instance of your ´Controller´ class per connection that processes the message. Since XSockets.NET does not recycle you will not loose data even though it is stored in-memory. Of course you should persist information that is important since information will be lost if/when the server is stopped.\r\n\r\nIf you want to send messages to clients from your own code that runs outside the `Controller` class but in the same context as the server, you can do it by instantiating a `Controller` class instance. Note: Instances created like this will not have a socket but they can still be used to send messages to clients connected on any `Controller`.\r\n\r\n####How to define methods in the Controller class that the clients can call\r\n\r\nTo expose a method on the `Controller` that you want to be callable from the client, declare a public method, as shown in the following examples.\r\n\r\n    public class Chat : XSocketController\r\n    {\r\n        public void ChatMessage(string message)\r\n        {\r\n            this.InvokeToAll(message,\"chatmessage\");\r\n        }\r\n    }\r\n    public class StockTicker : XSocketController\r\n    {\r\n        public IEnumerable<Stock> GetAllStocks()\r\n        {\r\n            return _stockTicker.GetAllStocks();\r\n        }\r\n    }\r\n    \r\nYou can specify a return type and parameters, including complex types and arrays, as you would in any C# method. Any data that you receive in parameters or return to the caller is communicated between the client and the server by using JSON, and XSockets.NET handles the binding of complex objects and arrays of objects automatically.\r\n\r\n####How to call client methods from the Controller class\r\nTo call client methods from the server, use the extensionmethods for the `IXSocketController` interface. The following example shows server code that calls `chatmessage` on all connected clients, and the client code that defines the method in a JavaScript and C# clients.\r\n\r\nThere are many extensions for both PUB/SUB and RPC, and you can of course write your own if needed.\r\n\r\nServer\r\n\r\n    public class Chat : XSocketController\r\n    {\r\n        public void ChatMessage(string message)\r\n        {\r\n            this.InvokeToAll(message,\"chatmessage\");\r\n        }\r\n    }\r\n    \r\nClient - JavaScript\r\n\r\n    conn.controller('chat').chatmessage = function(data){\r\n        console.log(data);\r\n    };\r\n\r\nClient - C#\r\n\r\n    conn.Controller(\"chat\").On<string>(\"chatmessage\", data => Console.WriteLine(data));\r\n    \r\nYou can specify complex types and arrays for the parameters. The following example passes a complex type to the client in a method parameter.\r\n\r\nServer code that calls a client method using a complex object\r\n\r\n    public void ChatMessage(string message)\r\n    {\r\n        this.InvokeToAll(new {Text=message},\"chatmessage\");\r\n    }\r\n\r\nWe use an anonymous \"complex\" object here, but you can of course create custom models (classes) as well.\r\n\r\nClient - JavaScript\r\n\r\n    conn.controller('chat').chatmessage = function(data){\r\n        console.log(data.Text);\r\n    };\r\n\r\nClient - C#\r\n\r\n    conn.Controller(\"chat\").On(\"chatmessage\", data => Console.WriteLine(data.Text));\r\n\r\n*Above we get a dynamic since we do not specify the datatype, but we can of course use a complex type to get the message deserialized into the correct type and get intellisense.*\r\n\r\n#### How to use state on the server\r\nAll public getters and setters are accessible from the client API, so you can actually `get` and `set` the `Controller` properties from the client API's.\r\n\r\nBelow you can see that the chat example is extended with a property for username. Since we can use `state` to know who the user is at all times there is no need passing the unnecessary data with every message.\r\n\r\nServer `Controller` with state\r\n\r\n    public class Chat : XSocketController\r\n    {\r\n        public string UserName {get;set;}\r\n        \r\n        public void ChatMessage(string message)\r\n        {\r\n            this.InvokeToAll(new {UserName = this.UserName, Text = message},\"chatmessage\");\r\n        }\r\n    }\r\n    \r\nSet the UserName from the client API's\r\n\r\nClient - JavaScript\r\n\r\n    conn.controller('chat').setProperty('username','Espen Knutsen');\r\n\r\nClient - C#\r\n\r\n    conn.Controller(\"chat\").SetProperty(\"username\",\"Espen Knutsen\");\r\n    \r\nSo to repeat... Since we at all times know the username there is no need for passing it to the server when we can attach the user on the message going out.\r\n\r\n####How to hide methods and properties\r\nYou might not wanna expose all publish methods and properties to the client API's. When you want to hide a publish method/property just decorate the method/property with the `[NoEvent]` attribute. The attribute is located under `XSockets.Core.Common.Socket.Event.Attributes`\r\n\r\n####How to use complex objects as parameters\r\nAbove we looked at how you can send complex types to the clients, of course the client can send complex types to the server as well.\r\n\r\n**Server**\r\n\r\nA simple model for our chat sample\r\n\r\n    public class ChatModel\r\n    {\r\n        public string UserName {get;set;}\r\n        public string Text {get;set;}\r\n    }\r\n\r\nServer code that accepts a complex object and sends it to all clients. Since we have the username (showed in `How to use state on the server`) we never pass that in, we only set it before sending data out.\r\n\r\n    public void ChatMessage(ChatModel message)\r\n    {\r\n        message.UserName = this.UserName;\r\n        this.InvokeToAll(message,\"chatmessage\");\r\n    }\r\n\r\n**Clients**\r\n\r\nClient - JavaScript\r\n\r\n    conn.controller('chat').invoke('chatmessage',{Text:'Hello from JS'});\r\n\r\nClient - C#\r\n\r\n    conn.Controller(\"chat\").Invoke(\"chatmessage\", new ChatModel{Text=\"Hello from CS\"});\r\n\r\n####How to use IMessage as parameter\r\nWhen you do not process the data server-side there is no need serializing incoming messages. In these situations you can use `IMessage` as parameter since any message sent into XSockets.NET will be transformed into `IMessage` internally.\r\n\r\nThis is how the `Generic` controller used in the `Getting started with real-time communication` sample is built. The code for `Generic` is very simple and looks exactly like this.\r\n\r\n    public class Generic : XSocketController\r\n    {\r\n        public override OnMessage(IMessage message)\r\n        {\r\n            this.InvokeToAll(message);\r\n        }\r\n    }\r\n    \r\nIn the `Generic` `Controller` we override the `OnMessage` method which means that any call to the `Controller` that does not match a `method` will end up in the `OnMessage` method.\r\n\r\nYou can of course use the `IMessage` parameter in regular methods on the `Controller` and not just the `OnMessage` method.\r\n\r\n####Return data synchronously to caller\r\nWhen you call the server from a client and want to wait for the result you just replace void with the type you want to return and the client API's will wait for the result.\r\n\r\n**Server**\r\n\r\n    public string Echo()\r\n    {\r\n        return \"Echo\";\r\n    }\r\n    \r\nYou can of course send data before doing the return, for example.\r\n\r\n    public string Echo()\r\n    {\r\n        this.InvokeToAll(\"someData\", \"someMethod\");\r\n        //and so on...\r\n        return \"Echo\";\r\n    }\r\n    \r\n**Clients**\r\n\r\nClient - JavaScript\r\n\r\n    conn.controller('chat').invoke('echo').then(function(d){console.log(d)});\r\n\r\nClient - C#\r\n\r\n    var echo = conn.Controller(\"chat\").Invoke<string>(\"echo\");\r\n    Console.WriteLine(echo.Result);\r\n\r\n####How to do overloading of methods\r\n\r\n    TBD\r\n\r\n####How to handle binary data\r\nLets say that we have a file `c:\\temp\\xfile.txt` with the text `This file was sent with XSockets.NET` and we want to send that file to the server.\r\n\r\n**Server**\r\n\r\n    public void MyFile(IMessage message)\r\n    {\r\n        var filecontent = Encoding.UTF8.GetString(message.Blob.ToArray());\r\n    }\r\n\r\n**Clients**\r\n\r\nClient - JavaScript\r\n\r\n    N/A\r\n\r\nClient - C#\r\n\r\n    var blob = File.ReadAllBytes(@\"c:\\temp\\xfile.txt\");\r\n    conn.Controller(\"chat\").Invoke(\"myfile\", blob);\r\n\r\n####How to pass meta-data together with binary data\r\nIf we want to attach metadata about the binary data that is easy to do. Just pass along the object representing the metadata and XSockets will let you extract that data on the server.\r\n\r\n**Server**\r\n    \r\n    //simple class for holding metadata about a file\r\n    public class FileInfo\r\n    {\r\n        public string Name {get;set;}\r\n    }\r\n\r\n    public void MyFile(IMessage message)\r\n    {\r\n        var filecontent = Encoding.UTF8.GetString(message.Blob.ToArray());\r\n        var metadata = message.Extract<FileInfo>();\r\n    }\r\n\r\nJust use `Extract<T>` to get back to metadata attached to the binary data.\r\n\r\n**Clients**\r\n\r\nClient - JavaScript\r\n\r\n    N/A\r\n\r\nClient - C#\r\n\r\n    var blob = File.ReadAllBytes(@\"c:\\temp\\xfile.txt\");\r\n    conn.Controller(\"chat\").Invoke(\"myfile\", blob, new {Name=\"xfile.txt\"});\r\n\r\n----------\r\n\r\n###RPC\r\nThe RemoteProcedureCall pattern let you do exactly what is says, call procedures remotely. RPC together with XSockets fine grained control let you send messages to specific clients in a very smooth way.\r\n\r\nYou will see more about this powerful feature combined with RPC below\r\n####How to call methods on the client\r\nIf you just want to send a message to the caller of the method, use `Invoke`\r\n\r\n**Server**\r\n    \r\n    //Send a message to the caller\r\n    this.Invoke(\"Hello to caller from server\", \"chatmessage\");\r\n\r\n**Client**\r\n\r\nClient - JavaScript\r\n\r\n    conn.controller('chat').chatmessage = function(data){console.log(data)};\r\n\r\nClient - C#\r\n\r\n    conn.Controller(\"chat\").On<string>(\"chatmessage\", data => Console.WriteLine(data));\r\n\r\n####How to call methods on all clients\r\nIf you want to send a message to all clients connected to the controller, use `InvokeToAll`\r\n\r\n**Server**\r\n    \r\n    this.InvokeToAll(\"Hello to all from server\", \"chatmessage\");\r\n\r\n**Client**\r\n\r\nClient - JavaScript\r\n\r\n    conn.controller('chat').chatmessage = function(data){console.log(data)};\r\n\r\nClient - C#\r\n\r\n    conn.Controller(\"chat\").On<string>(\"chatmessage\", data => Console.WriteLine(data));\r\n\r\n####How to target a subset of the connected clients\r\nIf you want to send a message to some of the clients connected to the controller, use `InvokeTo`\r\n\r\nThis is where you will see the power of state! You will actually get intellisense so that you can write lambda expressions to target the clients you want to send the message to.\r\n\r\nIf we have the properties Age and Gender on the `Controller` (for example) we can target exactly the ones we want to.\r\nBelow for example we send to all clients having the same gender and location as the caller\r\n\r\n**Server**\r\n    \r\n    this.InvokeTo(p => p.Gender == this.Gender && p.City == this.City,\"Hello to some from server\", \"chatmessage\");\r\n\r\n**Client**\r\n\r\nClient - JavaScript\r\n\r\n    conn.controller('chat').chatmessage = function(data){console.log(data)};\r\n\r\nClient - C#\r\n\r\n    conn.Controller(\"chat\").On<string>(\"chatmessage\", data => Console.WriteLine(data));\r\n\r\n####How to send messages to clients connected on another Controller class\r\nIt is pretty much the same as sending to the clients on the same `Controller` since XSockets extension-methods are generic.\r\n\r\nSo, if you are on `Controller` A and want to send to all clients on `Controller` B you just use...\r\n\r\n    //To all\r\n    this.InvokeToAll<B>(\"Hello to all from server\", \"target\");\r\n    \r\n    //And the powerful `InvokeTo<T>`  would have a signature like:\r\n    this.InvokeTo<T>(Func<T,bool> expression, object obj, string target);\r\n\r\n####How to call client methods outside the Controller class\r\nJust create a controller instance (or ask the plugin framework after the specific controller) and then use the extensions to send data\r\n\r\n    //Create the instance your self\r\n    var chat = new Chat();\r\n    //Then just use one of the extensions to target, one, some, others or all...\r\n    chat.InvokeToAll<Chat>(\"Hello from manual instance\",\"say\");\r\n    \r\nNotice that you have to pass in <T> in the extension regardless of what controller you want to use. So you can even do `new Chat().InvokeToAll<Stock>(\"Hello to stock clients from chat instance\",\"hi\");`\r\n    \r\n*Note: there is no point in using Invoke/Publish/Send since the actual controller does not have a socket since there is no client connected to it (we created the instance manually).*\r\n\r\n----------\r\n\r\n###PUB/SUB\r\nThe publish/subscribe pattern is useful when your applications need the users to subscribe to the topics that you are about to publish. Of course you can have very good control with XSockets since you can select subsets of subscribers very easy to get more fine grained control.\r\n\r\nYou will see more about this powerful feature combined with PUB/SUB below.\r\n####How to publish data to subscribers\r\nIf you just want to send a message to the publisher/caller of the method, use `Publish`\r\nThe big difference between `Publish` and `Invoke` is that the message only will arrive at the client if the client has a `Subscription` registered on the server.\r\n\r\n**Server**\r\n    \r\n    //Publish a message to the caller\r\n    this.Publish(\"Hello to caller from server\", \"chatmessage\");\r\n\r\n**Client**\r\n\r\nClient - JavaScript\r\n\r\n    conn.controller('chat').subscribe('chatmessage', function(data){\r\n        console.log(data);\r\n    });\r\n\r\nClient - C#\r\n\r\n    conn.Controller(\"chat\").Subscribe<string>(\"chatmessage\", data => Console.WriteLine(data) );\r\n\r\n####How to publish to all subscribers\r\nIf you want to publish a message to all clients subscribing to a topic, use `PublishToAll`\r\n\r\n**Server**\r\n    \r\n    this.PublishToAll(\"Hello to all subscribers from server\", \"chatmessage\");\r\n\r\n**Client**\r\n\r\nClient - JavaScript\r\n\r\n    conn.controller('chat').subscribe('chatmessage', function(data){\r\n        console.log(data)\r\n    });\r\n\r\nClient - C#\r\n\r\n    conn.Controller(\"chat\").On<string>(\"chatmessage\", data => Console.WriteLine(data));\r\n\r\n####How to publish to a subset of the subscribing clients\r\nIf you want to send a message to some of the subscribing clients, use `PublishTo`\r\n\r\nThis is where you will see the power of state! You will actually get intellisense so that you can write lambda expressions to target the subscribers you want to send the message to.\r\n\r\nIf we have the properties Age and Gender on the `Controller` (for example) we can target exactly the ones we want to.\r\nBelow for example we send to all clients having the same gender and location as the caller\r\n\r\n**Server**\r\n    \r\n    this.PublishTo(p => p.Gender == this.Gender && p.City == this.City,\"Hello to some from server\", \"chatmessage\");\r\n\r\n**Client**\r\n\r\nClient - JavaScript\r\n\r\n    conn.controller('chat').subscribe('chatmessage', function(data){\r\n        console.log(data)\r\n    });\r\n\r\nClient - C#\r\n\r\n    conn.Controller(\"chat\").On<string>(\"chatmessage\", data => Console.WriteLine(data));\r\n\r\n####How to publish messages to subscribers connected on another Controller class\r\nIt is pretty much the same as publishing to the clients on the same `Controller` since XSockets extension-methods are generic.\r\n\r\nSo, if you are on `Controller` A and want to publish to all `chatmessage` subscribers on `Controller` B you just use...\r\n\r\n    //To all\r\n    this.PublishToAll<B>(\"Hello to all 'chatmessage' subscribers on 'controller' B from server\", \"chatmessage\");\r\n    \r\n    //And the powerful `PublishTo<T>`  would have a signature like:\r\n    this.PublishTo<T>(Func<T,bool> expression, object obj, string target);\r\n\r\n####How to call subscribers outside the Controller class\r\nJust create a controller instance (or ask the plugin framework after the specific controller) and then use the extensions to send data\r\n\r\n    //Create the instance your self\r\n    var chat = new Chat();\r\n    //Then just use one of the extensions to target, one, some, others or all...\r\n    chat.PublishToAll<Chat>(\"Hello from manual instance\",\"say\");\r\n    \r\nNotice that you have to pass in <T> in the extension regardless of what controller you want to use. So you can even do `new Chat().PublishToAll<Stock>(\"Hello to stock clients from chat instance\",\"hi\");`\r\n\r\n*Note: there is no point in using Invoke/Publish/Send since the actual controller does not have a socket since there is no client connected to it (we created the instance manually).*\r\n    \r\n----------\r\n\r\n###How to handle connection lifetime events in the Controller class\r\nEach controller have events that you can use to know when `Open`, `Close` and `ReOpen` occurs.\r\n\r\n####The OnOpen event\r\nWill fire when the controller is used over the connection for the first time.\r\n    \r\n    public class Chat : XSocketController\r\n    {\r\n        public Chat()\r\n        {\r\n            this.OnOpen += Chat_OnOpen;\r\n        }\r\n\r\n        void Chat_OnOpen(object sender, OnClientConnectArgs e)\r\n        {\r\n            //Connection to controller is open\r\n        }\r\n    }\r\n\r\n####The OnClose event\r\nWill fire when the socket is closed or if the client choose to close this specific controller on the connection.\r\n\r\n    public class Chat : XSocketController\r\n    {\r\n        public Chat()\r\n        {\r\n            this.OnClose += Chat_OnClose;\r\n        }\r\n\r\n        void Chat_OnClose(object sender, OnClientDisconnectArgs e)\r\n        {\r\n            //Connection to controller was closed\r\n        }\r\n    }\r\n\r\n####How to do heartbeats (ping/pong control-frames)\r\nControl-frames (ping/pong) is primarily for checking connections, measure latency and validate that the connection is valid.\r\n\r\nYou can implement custom logic for sending/receiving these frames on the server, but there is a simple helper that you can use to get the functionality.\r\n\r\n    public class Chat : XSocketController\r\n    {\r\n        public Chat()\r\n        {\r\n            this.OnOpen += Chat_OnOpen;\r\n        }\r\n\r\n        void Chat_OnOpen(object sender, OnClientConnectArgs e)\r\n        {\r\n            this.ProtocolInstance.Heartbeat(notifyAction: (reason)=>{ Console.WriteLine(reason); });\r\n        }\r\n    }\r\n\r\n### Modules/Plugins\r\nThis section covers how to create custom modules/plugins for different parts of XSockets. This only covers the `Interfaces` within XSockets, but you can ofcourse add your custom interfaces as plugins by telling the plugin framework about the interfaces you want to use. Read more about custom plugin in `The Plugin Framework` section\r\n\r\n####How to implement your custom Pipeline\r\nThe server will only have one `XSockets.Core.Common.Socket.IXSocketPipeline`, but you can override the default one by just deriving it.\r\n\r\nEach message passing into the server or out of the server will pass the pipeline\r\n\r\n    public class MyPipeline : XSocketPipeline\r\n    {\r\n        public override void OnIncomingMessage(IXSocketController controller, IMessage e)\r\n        {\r\n            Debug.WriteLine(string.Format(\"IN:  Controller:{}, Topic:{1}, Data:{2}\", e.Controller, e.Topic, e.Data));\r\n            base.OnIncomingMessage(controller, e);\r\n        }\r\n\r\n        public override IMessage OnOutgoingMessage(IXSocketController controller, IMessage e)\r\n        {\r\n            Debug.WriteLine(string.Format(\"OUT: Controller:{}, Topic:{1}, Data:{2}\", e.Controller, e.Topic, e.Data));\r\n            return base.OnOutgoingMessage(controller, e);\r\n        }\r\n    }\r\n    \r\n#### Write a custom AuthenticationPipeline\r\nWhen the socket is connected and the handshake is completed the `AuthenticationPipeline` will be called. By default the pipeline will look for a FormsAuthenticationTicket, but you can override this pipline by just implementing a interface `XSockets.Core.Common.Socket.IXSocketAuthenticationPipeline`\r\n\r\nThere can only be one pipeline so even if you implement several pipelines only one wil be used.\r\n\r\n    [Export(typeof(IXSocketAuthenticationPipeline))]\r\n    public class MyAuthenticationPipeline : IXSocketAuthenticationPipeline\r\n    {\r\n        public IPrincipal GetPrincipal(IXSocketProtocol protocol)\r\n        {            \r\n            if (protocol.ConnectionContext.User == null)\r\n            {\r\n                //creating a fake super user ;)\r\n                var roles = new string[]{\"superman\",\"hulk\"};\r\n                var userIdentity = new GenericIdentity(\"David\");\r\n                protocol.ConnectionContext.User = new GenericPrincipal(userIdentity, roles);\r\n            }            \r\n\r\n            return protocol.ConnectionContext.User;\r\n        }\r\n    }\r\n\r\n#### Interceptors Concept\r\nThere can only be one `Pipeline`, and one `AuthenticationPipeline`, but interceptors can be 0 to N. Every interceptor will be called at a specific time. ConnectionInterceptors for example will be called when someone connects, disconnects or when a handshake is completed (ok or not).\r\n\r\nInterceptors are common when debugging or logging, but XSockets does not choose a logger for you. Implement the interface and do whatever you want inside of the interceptor(s).\r\n\r\n##### How to write ConnectionInterceptors\r\nSample of a connection interceptor that logs handshake and connect/disconnect with `debug` level\r\n\r\n    public class MyConnectionInterceptor : IConnectionInterceptor\r\n    {\r\n\r\n        public void Connected(IXSocketProtocol protocol, string controller)\r\n        {\r\n            LogHelper.Log(LogEventLevel.Verbose, \"Connected {controller} {@protocol}\",controller ,protocol.ConnectionContext);            \r\n        }\r\n\r\n        public void Disconnected(IXSocketProtocol protocol, string controller)\r\n        {\r\n            LogHelper.Log(LogEventLevel.Verbose, \"Disconnected {controller} {@protocol}\", controller, protocol.ConnectionContext);\r\n        }\r\n\r\n        public void HandshakeCompleted(IXSocketProtocol protocol)\r\n        {\r\n            LogHelper.Log(LogEventLevel.Verbose, \"Handshake ok {@protocol}\", protocol.ConnectionContext);\r\n        }\r\n\r\n        public void HandshakeInvalid(string rawHandshake)\r\n        {\r\n            LogHelper.Log(LogEventLevel.Verbose, \"Handshake failed {raw}\", rawHandshake);\r\n        }\r\n    }\r\n    \r\n######How to write MessageInterceptors\r\nSample of a message interceptor that logs in/out messages with `debug` level\r\n\r\n    public class MyMessageInterceptor : IMessageInterceptor\r\n    {\r\n        public void OnIncomingMessage(IXSocketProtocol protocol, IMessage message)\r\n        {\r\n            LogHelper.Log(LogEventLevel.Debug, \"{incoming message {@message}}\", message);\r\n        }\r\n\r\n        public void OnOutgoingMessage(IXSocketProtocol protocol, IMessage message)\r\n        {\r\n            LogHelper.Log(LogEventLevel.Debug, \"{outgoing message {@message}}\", message);\r\n        }\r\n    }\r\n    \r\n######How to write ErrorInterceptors\r\nSample of a error interceptor that logs exceptions with `error` level\r\n\r\n    public class MyErrorInterceptor : IErrorInterceptor\r\n    {\r\n        public void OnError(IXSocketException exception)\r\n        {\r\n            LogHelper.Log(LogEventLevel.Error, \"{Exception {@ex}}\", exception);\r\n        }\r\n    }\r\n    \r\n####How to write a custom JSON Serializer\r\nYou can replace the default serializer with your own favorite serializer. As everything else in XSockets.NET it is just a module/plugin. Implement the `IXSocketJsonSerializer` interface and export the new plugin to tell XSockets to use your serializer instead of the defualt one.\r\n\r\nIn the sample below we use the ServiceStack.Text serializer\r\n\r\n    using System;\r\n    using System.Collections.Generic;\r\n    using System.Linq;\r\n    using ServiceStack.Text;\r\n    using XSockets.Core.Common.Utility.Serialization;\r\n\r\n    namespace MyNameSpace.Serialization\r\n    {\r\n        [Export(typeof(IXSocketJsonSerializer))]\r\n        public class MyJsonSerializer : IXSocketJsonSerializer\r\n        {\r\n            public MyJsonSerializer()\r\n            {\r\n                JsConfig.ExcludeTypeInfo = true;\r\n                JsConfig.IncludeTypeInfo = false;\r\n            }\r\n\r\n            public string SerializeToString<T>(T obj)\r\n            {\r\n                return JsonSerializer.SerializeToString(obj);            \r\n            }\r\n\r\n            public string SerializeToString(object obj, Type type)\r\n            {\r\n                return JsonSerializer.SerializeToString(obj, type);\r\n            }\r\n\r\n            public T DeserializeFromString<T>(string json)\r\n            {\r\n                return JsonSerializer.DeserializeFromString<T>(json);\r\n            }\r\n\r\n            public object DeserializeFromString(string json, Type type)\r\n            {           \r\n                return JsonSerializer.DeserializeFromString(json, type);\r\n            }\r\n\r\n            public IDictionary<string,string> DeserializeFromString(string json, params string[] keys)\r\n            {\r\n                var obj = JsonSerializer.DeserializeFromString<List<JsonObject>>(@json);\r\n                return keys.ToDictionary(key => key, key => obj[0].Child(key));\r\n            }\r\n        }    \r\n    }\r\n    \r\n####How to write custom Protocols\r\n\r\n    TODO\r\n    \r\n###Securing the Controller\r\nXSockets.NET does not provide any features for authenticating users. Instead, you integrate the XSockets:NET features into the existing authentication structure for an application. You authenticate users as you would normally in your application, and work with the results of the authentication in your XSockets.NET code. For example, you might authenticate your users with ASP.NET forms authentication, and then in your `Controller`, enforce which users or roles are authorized to call a method.\r\n\r\nXSockets provides the Authorize attribute to specify which users have access to a `controller` or `method`. You apply the Authorize attribute to either a `controller` or particular `methods` in a `controller`. Without the Authorize attribute, all public methods on the controller are available to a client that is connected to the controller. \r\n\r\nIf you want to allow unrestrcited access on some methods you can add the `AllowAnonymous` attribute the these methods.\r\n\r\nMore information about attributes and methods below\r\n\r\n#### Authorize Attribute\r\n\r\nThis attribute can be set on Controller or Method level. If set at controller level all action methods that do not have the `AllowAnonymous` attribute will require authentication.\r\n\r\nThe authorize attribute can take Roles and Users but if using that you will have to implement your own authentication by overriding `OnAuthorization(AuthorizeAttribute authorizeAttribute)`\r\n\r\n#### AllowAnonymous Attribute\r\n\r\nThis attribute can be set on action methods and will then allow anonymous access.\r\n\r\n#### Get FormsAuthentication Ticket\r\n\r\nWhen you have custom authentication you can get the `FormsAuthenticationTicket` from this method.\r\n\r\n    var ticket = GetFormsAuthenticationTicket();\r\n\r\n**Note: If you do not pass in a cookiename .ASPXAUTH will be used.**\r\n\r\n**Important: If you have separate project you will have to use the same origin to be able to get cookies and also use machine-key in the config to be able to get the AuthCookie.**\r\n***See*** [machinekey compability mode][3] ***if you are using different framework versions in the projects.***\r\n\r\n#### Write a custom AuthenticationPipeline\r\nWhen the socket is connected and the handshake is completed the `AuthenticationPipeline` will be called. By default the pipeline will look for a FormsAuthenticationTicket, but you can override this pipline by just implementing a interface `XSockets.Core.Common.Socket.IXSocketAuthenticationPipeline`\r\n\r\nThere can only be one pipeline so even if you implement several pipelines only one wil be used.\r\n\r\n    [Export(typeof(IXSocketAuthenticationPipeline))]\r\n    public class MyAuthenticationPipeline : IXSocketAuthenticationPipeline\r\n    {\r\n        public IPrincipal GetPrincipal(IXSocketProtocol protocol)\r\n        {            \r\n            if (protocol.ConnectionContext.User == null)\r\n            {\r\n                //creating a fake super user ;)\r\n                var roles = new string[]{\"superman\",\"hulk\"};\r\n                var userIdentity = new GenericIdentity(\"David\");\r\n                protocol.ConnectionContext.User = new GenericPrincipal(userIdentity, roles);\r\n            }            \r\n            return protocol.ConnectionContext.User;\r\n        }\r\n    }\r\n\r\n#### How to override the OnAuthorization method\r\nThe `OnAuthorization` method is called for every method on a controller that has authentication. The attribute for the method (or controller) is passed in and we check that \r\n\r\n 1. That the user is authenticated\r\n 2. If the user name is required we verify a match\r\n 3. If user name was not required or did not match we check roles\r\n\r\n        public virtual bool OnAuthorization(IAuthorizeAttribute authorizeAttribute)\r\n        {\r\n            try\r\n            {\r\n                var user = this.ProtocolInstance.ConnectionContext.User;\r\n                if (user.Identity.IsAuthenticated)\r\n                {\r\n                    if (!string.IsNullOrEmpty(authorizeAttribute.Roles) || !string.IsNullOrEmpty(authorizeAttribute.Users))\r\n                    {                    \r\n                        if (authorizeAttribute.Users.Split(',').Contains(user.Identity.Name)){\r\n                            return true;\r\n                        }\r\n                        return authorizeAttribute.Roles.Split(',').Any(user.IsInRole);      \r\n                    }\r\n                    return true;\r\n                }\r\n                return false;\r\n            }\r\n            catch\r\n            {\r\n                return false;\r\n            }\r\n        }\r\n\r\n**Example**\r\nBased on the `Write a custom AuthenticationPipeline` where we added the username `Hero` and the roles `hulk`, `superman` we have the following scenario\r\n\r\n    [Authorize()] //would be valid since we have a authorized `fake` user\r\n\r\n    [Authorize(Users = \"David\")] //would be valid\r\n\r\n    [Authorize(Roles = \"batman,robin\")] //would be invalid\r\n    \r\n    [Authorize(Roles = \"batman,hulk\")] //would be valid\r\n    \r\n#### How to know when authorization fails\r\nEvery time a method on a controller needs authentication the `OnAuthorization` method is called (which was overridden in previous sample).\r\n\r\nWhen the `OnAuthorization` returns false the `OnAuthorizationFailed` event is fired.\r\n\r\n    //Constructor\r\n    public Chat()\r\n    {\r\n        this.OnAuthorizationFailed += Chat_OnAuthorizationFailed;\r\n    }\r\n\r\n    void Chat_OnAuthorizationFailed(object sender, OnAuthorizationFailedArgs e)\r\n    {\r\n        Console.WriteLine(\"Auth Failed: {0},{1}\", e.Controller, e.MethodName); \r\n    }\r\n\r\nThe `OnAuthorizationFailedArgs` contains information about the controller and the method being called. Information about the user that called the method can be accessed from `this.ProtocolInstance.ConnectionContext.User`\r\n\r\n###How to handle errors in the Controller class\r\nWrap you logic in a try catch block and call the `HandleError` method that will invoke the `OnError` event. \r\n\r\nWhen needed you can also send the error to the `ErrorInterceptors` if you have implemented any.\r\n\r\n    try\r\n    {\r\n        throw new Exception(\"boom!\");\r\n    }\r\n    catch(Exception ex)\r\n    {\r\n        this.HandleError(ex);\r\n        ErrorInterceptorsQueue.Push(ex);\r\n    }\r\n\r\n###How to create internal (long-running) Controllers\r\nA common scenario is that you want to do something every x seconds on the server. It can be polling a legacy database etc. And then push information to clients based on criterias just as you do in any XSockets server side method.\r\n\r\nIn XSockets you can write long-running controllers. A long-running controller will be a `singleton` that only executes inside of the server. Clients can´t connect to a long-running controller.\r\n\r\nThe simple sample below will send a chatmessage to all clients connected to the `Chat` controller from the long-running controller. The line that will make the controller a long-running controller is `[XSocketMetadata(\"MyLongrunningController\", PluginRange.Internal)]` That tells XSockets to use the controller as a singleton and that it should be internal only.\r\n\r\n    /// <summary>\r\n    /// This is a longrunning controller. This cant be connected to.\r\n    /// It is a singleton that will run inside xsockets as long as the server is alive.\r\n    /// Most common is to start a timer in it to perform some task\r\n    /// </summary>\r\n    [XSocketMetadata(\"MyLongrunningController\", PluginRange.Internal)]   \r\n    public class MyLongrunningController : XSocketController\r\n    {\r\n        private Timer timer;\r\n        \r\n        public MyLongrunningController()\r\n        {\r\n            timer = new Timer(10000);\r\n            timer.Elapsed += timer_Elapsed;\r\n            timer.Start();\r\n        }\r\n\r\n        void timer_Elapsed(object sender, ElapsedEventArgs e)\r\n        {\r\n            //Sending a message to all clients on the Chat controller\r\n            this.InvokeToAll<Chat>(\"Hello from long-running controller\", \"say\");\r\n        }\r\n    }\r\n\r\n###How to get information about the client from the ConnectionContext\r\n\r\n####Getting Cookies\r\nYou can get the `CookieCollection` by using\r\n\r\n    var cookies = this.ProtocolInstance.ConnectionContext.CookieCollection;\r\n\r\nNote: you will only be able to access cookies if your server is on the same domain as the cookie domain.\r\n\r\n####Getting Headers\r\nYou can get the headers `NameValueCollection` by using\r\n\r\n    var headers = this.ProtocolInstance.ConnectionContext.Headers;\r\n\r\n####Getting Query Strings\r\nYou can access the query string `NameValueCollection` by using\r\n\r\n    var querystring = this.ProtocolInstance.ConnectionContext.QueryString;\r\n\r\n####Getting the current User (IPrincipal)\r\nYou can get/set the IPrincipal by using\r\n\r\n    var principal = this.ProtocolInstance.ConnectionContext.User;\r\n\r\n\r\n----------\r\n\r\n## C# Client API Guide\r\nThe C# Client API has support for:\r\n\r\n - .NET 3.5, 4.0+\r\n - iOS (MonoTouch)\r\n - Android (MonoDroid)\r\n - .NET MicroFramework 4.2, 4.3\r\n\r\n###Client Setup\r\nTo get the client just get the latest package from [nuget.org/packages/xsockets.client][4]\r\n\r\nThe C# clients ALWAYS talk full-duplex/bi-directional communication, and just like the XSockets server this behavior has nothing to do with what OS or WebServer you are running.\r\n\r\n###How to establish a connection\r\nJust like in the JavaScript client you can multiplex over several `Controller` on one connection. To get a connections just create an instance of the XSocketClient.\r\n\r\n    var conn = new XSocketClient(\"ws://localhost:4502\", \"http://localhost\", \"chat\");\r\n    conn.Open();\r\n    \r\n- The first parameter is the endpoint of the server\r\n- The second parameter is the origin of the client\r\n- The third parameter is params string[] for setting your controllers\r\n\r\nDo note that the call to `Open` is synchron and will wait until the connection is open and the handshake is completed.\r\n\r\n###How to configure the connection\r\n####How to use multiple Controllers\r\nTo multiplex over several controllers on one connection you just pass in the controllers to use.\r\n\r\nBelow we connect to `Controllers` `one` and `two`\r\n\r\n    var conn = new XSocketClient(\"ws://localhost:4502\", \"http://localhost\", \"one\",\"two\");\r\n    \r\nDo note that you do not have to specify all controllers in the creation of the client. As soon as you start using a controller in the client API you will get an instance of it.\r\n\r\nSo if there is no controller `three` defined in the connection you can still do:\r\n\r\n    conn.Controller(\"three\").Invoke(\"somemethod\");\r\n\r\n####How to specify query string parameters\r\nYou can add querystrings to the `NameValueCollection` named `QueryString` on the `IXSocketClient`\r\n    \r\n    var conn = new XSocketClient(\"ws://localhost:4502\",\"http://xsockets.net\", \"chat\");\r\n    conn.QueryString.Add(\"color\",\"blue\");\r\n    conn.Open();\r\n    \r\n####How to specify HTTP headers\r\n\r\n    var conn = new XSocketClient(\"ws://localhost:4502\",\"http://xsockets.net\", \"chat\");\r\n    conn.Headers.Add(\"headername\", \"headervalue\");\r\n    conn.Open();\r\n    \r\n####How to specify client credentials\r\n\r\n##### Connection header\r\n    \r\n    TODO\r\n\r\n##### Cookie with Forms Authentication\r\n\r\n    var authTicket = new FormsAuthenticationTicket(1, \"Uffe\",DateTime.Now,DateTime.Now.AddMinutes(15),false, \"batman|hulk\");            \r\n    string encTicket = FormsAuthentication.Encrypt(authTicket);\r\n    var authcookie = new Cookie(FormsAuthentication.FormsCookieName, encTicket);\r\n    conn.Cookies.Add(authcookie);\r\n\r\n##### Certificate\r\n    \r\n    TODO\r\n    \r\n##### Windows Authentication\r\n\r\n    TODO\r\n    \r\n###RPC\r\n####How to define methods on the client that the server can call\r\nYou define the methods per `Controller` since one connection can communicate over several `Controllers`\r\n\r\n**Client**\r\n\r\nThe example below creates a listener for `ChatMessage` and it expects the data to be a string.\r\n\r\n    conn.Controller(\"chat\").On<string>(\"chatmessage\", data => Console.WriteLine(data));\r\n\r\n**Server**\r\n\r\nThe server code for the examples with the `ChatModel` can look like\r\n\r\n    this.InvokeToAll(\"I am Yogi the gummi bear\",\"chatmessage\");\r\n\r\n####Methods without parameters\r\nIf the method you're handling does not have parameters just use the non generic `On` method.\r\n\r\n**Server**\r\n\r\n    public class Chat : XSocketController\r\n    {\r\n        public void CallAllClients()\r\n        {\r\n            this.InvokeToAll(\"test\");\r\n        }\r\n    }\r\n    \r\nNote: You can of course use `InvokeTo<T>` or `Invoke` as well\r\n\r\n**Client**\r\n    \r\n    conn.Controller(\"chat\").On(\"test\", () => Console.WriteLine(\"Test Was Called\"));\r\n\r\n####Methods with parameters, specifying parameter types\r\n\r\nIf we have a complex object being sent from the server, like the `ChatModel` we can of course just do like this\r\n\r\n    conn.Controller(\"chat\").On<ChatModel>(\"chatmessage\", data => Console.WriteLine(data.UserName + \" - \" + data.Text));\r\n    \r\n**Server**\r\n\r\nThe server code for the examples with the `ChatModel` can look like\r\n\r\n    this.InvokeToAll(new ChatModel{Name=\"Yogi\", Text=\"I am a gummi bear\"},\"chatmessage\");\r\n\r\n####Methods with parameters, specifying dynamic objects for the parameters\r\nAs an alternative to specifying parameters as generic types of the On method, you can specify parameters as dynamic objects. Below we get the `data` parameter as an dynamic since we did not specify the generic parameter for the `On` method.\r\n\r\n    conn.Controller(\"chat\").On(\"chatmessage\", data => Console.WriteLine(data.Text));\r\n    \r\n*Note: Dynamic keyword will not exist in clients for Android/iOS or .NET 3.5 and earlier.*\r\n\r\n**Server**\r\n\r\nThe server code for the examples with the `ChatModel` can look like\r\n\r\n    this.InvokeToAll(new ChatModel{Name=\"Yogi\", Text=\"I am a gummi bear\"},\"chatmessage\");\r\n    \r\n####Methods with parameter of type IMessage\r\nIf you for some reason want the actual IMessage sent from the server to the client you can specify IMessage as the type. You will then get the complete object that the client received!\r\n\r\n    conn.Controller(\"chat\").On<IMessage>(\"chatmessage\", o => Console.WriteLine(\"{0}, {1} {2}, {3},\",o.Controller, o.Topic, o.Data, o.MessageType);\r\n    \r\nIf you know the type contained in the Data part of the IMessage you can use Extract<T> to get the value.\r\n\r\n    //example extracting the JSON into a specific type\r\n    var chatModel = o.Extract<ChatModel>();\r\n    \r\n*Note: Dynamic keyword will not exist in clients for Android/iOS or .NET 3.5 and earlier.*\r\n\r\n**Server**\r\n\r\nThe server code for the examples with the `ChatModel` can look like\r\n\r\n    this.InvokeToAll(new ChatModel{Name=\"Yogi\", Text=\"I am a gummi bear\"},\"chatmessage\");\r\n    \r\n####How to remove a handler\r\nWhen you want to dispose of a handler you have to remove it from the `Controller` where it was used.\r\n\r\n    var listener = conn.Controller(\"chat\").On<string>(\"chatmessage\", data => Console.WriteLine(data));   \r\n                \r\n    conn.Controller(\"chat\").DisposeListener(listener);\r\n\r\n####How to send to server methods from the client\r\nTo call a method on the server, use the Invoke method on the `Controller`.\r\n\r\nIf the server method has no return value, use the non-generic overload of the Invoke method.\r\n\r\n**Server - method without return value**\r\n\r\n    public class Chat : XSocketController\r\n    {\r\n        protected string UserName {get;set;}\r\n        public void SetUserName(string userName)\r\n        {\r\n            this.UserName = userName;\r\n        }\r\n    }\r\n    \r\n**Client - calling a method that has no return value**\r\n\r\n    conn.Controller(\"chat\").Invoke(\"setusername\", new {userName = \"Steve\"});\r\n\r\n####How to call a server side method and wait for the result\r\nIf the server method has a return value, specify the return type as the generic type of the Invoke method.\r\n\r\n**Server - for a method that has a return value**\r\n\r\n    public IEnumerable<Stock> GetStocks()\r\n    {\r\n        return _stockTicker.GetAllStocks();\r\n    }\r\n    \r\nThe Stock class used for return value\r\n\r\n    public class Stock\r\n    {\r\n        public string Symbol { get; set; }\r\n        public decimal Price { get; set; }\r\n    }\r\n\r\n\r\n**Client - calling a method that has a return value in a synchronous method**\r\n\r\n    var stocks = conn.Controller(\"stockticker\").Invoke<IEnumerable<Stock>>(\"GetStocks\");\r\n    foreach (Stock stock in stocks)\r\n    {\r\n        Console.WriteLine(\"Symbol: {0} price: {1}\\n\", stock.Symbol, stock.Price);\r\n    }\r\n    \r\nIf there is no respons for 2000 ms there will be a `TimeoutException` so you should wrap the synchronous call like:\r\n\r\n    try\r\n    {\r\n        var stocks = conn.Controller(\"stockticker\").Invoke<IEnumerable<Stock>>(\"GetStocks\");\r\n        foreach (Stock stock in stocks)\r\n        {\r\n            Console.WriteLine(\"Symbol: {0} price: {1}\\n\", stock.Symbol, stock.Price);\r\n        }\r\n    }\r\n    catch (AggregateException ae)\r\n    {\r\n        ae.Handle((x) =>\r\n        {\r\n            if (x is TimeoutException)\r\n            {\r\n                //The communication did not respond within given time frame\r\n                //Handle it...\r\n                return true;\r\n            }\r\n            //Another exception handle it... or return false to stop app\r\n            return false;\r\n        });\r\n    }\r\n    \r\nOf course you can set the default 2000 ms to be longer or shorter if needed. Just pass in your timeout as a parameter in the call like\r\n    \r\n    //Timeout will now be 5 seconds\r\n    var stocks = conn.Controller(\"stockticker\").Invoke<IEnumerable<Stock>>(\"GetStocks\",5000);\r\n    \r\n###PUB/SUB\r\n####How to define subscription methods on the client that the server can publish to\r\n\r\n    conn.Controller(\"stockticker\").Subscribe<Stock>(\"newStock\", data => Console.WriteLine(\"Symbol: {0} price: {1}\\n\", stock.Symbol, stock.Price));\r\n        \r\n####How to subscribe one time\r\nIf you only want to get a message once and then unsubscribe automatically you can use `one`\r\n\r\n    conn.Controller(\"stockticker\").One<Stock>(\"newStock\", data => Console.WriteLine(\"Symbol: {0} price: {1}\\n\", stock.Symbol, stock.Price));\r\n    \r\nThis will make sure that the client unsubscribe to the topic after getting the first message.\r\n\r\n####How to subscribe n times\r\nIf you want to get a message 1 to n times and then unsubscribe automatically you can use `many`\r\n\r\n    conn.Controller(\"stockticker\").Many<Stock>(\"change\", 3, data => Console.WriteLine(data));\r\n\r\nThis will unsubscribe the `change` topic after getting 3 messages.    \r\n\r\n#### How to know when the subscription is ready\r\nWhen you compare PUB/SUB with RPC an obvious disadvantage with PUB/SUB is that you do not know if the server has bound the subscription when you do a publish. Therefor you can pass in an additional function to get a callback from the server when the subscription is completed.\r\n\r\nThis works similar for all subscribe methods.\r\n\r\n    Subscribe<T>(string topic, Action<T> callback, Action<IMessage> confirmCallback);\r\n    One<T>(string topic, Action<T> callback, Action<IMessage> confirmCallback);\r\n    Many<T>(string topic, uint limit, Action<T> callback, Action<IMessage> confirmCallback);\r\n    \r\nwhere `callback` is called when a publish occurs and `confirmCallback` is the callback that confirms the subscription. \r\n\r\n####How to remove a subscription\r\nWhen you no longer want to subscribe to a `topic` you just use the `unsubscribe` method to tell the server to remove the subscription.\r\n\r\n    conn.Controller(\"chat\").Unsubscribe(\"chatmessage\");\r\n\r\n####How to publish to server methods from the client\r\n\r\n**Client**\r\n\r\n    conn.Controller(\"chat\").Publish(\"chatmessage\",new {Text= \"Hello people!\"});\r\n\r\n**Server**\r\n\r\n    //The server migth publish the message back to all clients subscribing\r\n    public void ChatMessage(ChatModel chatModel)\r\n    {\r\n        this.PublishToAll(chatModel, \"chatmessage\");\r\n    }\r\n\r\n###How to handle connection lifetime events\r\nThe events on connection level provide information about the socket being opened/closed. The controllers has their own lifetime events.\r\n\r\n#### OnConnected\r\n\r\n    conn.OnConnected += (sender, eventArgs) => Console.WriteLine(\"Connected\");\r\n    conn.Open();\r\n                \r\n#### OnDisconnected\r\n    \r\n    conn.OnDisconnected += (sender, eventArgs) => Console.WriteLine(\"Disconnected\");\r\n    conn.Open();\r\n    \r\n###How to handle controller lifetime events\r\nThe controller has nothing to do with the actual socket. These events tell you about the controllers you are using over your connection.\r\n\r\n#### OnOpen\r\n\r\n    conn.Controller(\"chat\").OnOpen += (sender, connectArgs) => {\r\n        Console.WriteLine(\"Opened\");\r\n    };\r\n\r\n#### OnClose\r\n    \r\n    conn.Controller(\"chat\").OnClose += (sender, disconnectArgs) =>{\r\n        Console.WriteLine(\"Closed\");\r\n    };\r\n\r\n### Open a controller\r\nAs soon as you start to communicate over a new controller the `OnOpen` event will fire. You actually do not need to specify the controller in the connection. As long as the controller exists on the server the `OnOpen` event will fire.\r\n\r\n### Close a controller\r\nTo close as controller (not the actual connection/socket) you just call the `Close` method on the controller instance. This will fire the `OnClose` event on the controller.\r\n\r\n    conn.Controller(\"chat\").Close();\r\n\r\n#### OnOpen\r\n\r\n    conn.Controller(\"chat\").OnOpen += (sender, connectArgs) => {\r\n        Console.WriteLine(\"Open {0}\", connectArgs.ClientInfo.Controller);\r\n    };\r\n    \r\n#### OnClose\r\n\r\n    conn.Controller(\"chat\").OnClose += (sender, disconnectArgs) => {\r\n        Console.WriteLine(\"Closed {0}\", disconnectArgs.ClientInfo.Controller);\r\n    };\r\n\r\n###How to handle errors\r\n\r\nTo handle errors that the client raises, you can add a handler for the Error event on the connection object.\r\n\r\n    conn.OnError += (sender, errorArgs) => Console.WriteLine(errorArgs.Exception.Message);\r\n    \r\nYou may also handle errors on individual controller using the OnError event on a specific controller.\r\n\r\n    conn.Controller(\"chat\").OnError += (sender, errorArgs) => Console.WriteLine(errorArgs.Exception.Message);\r\n\r\nTo handle errors from method invocations, wrap the code in a try-catch block. \r\n\r\n    try\r\n    {\r\n        var stocks = conn.Controller(\"stockticker\").Invoke<IEnumerable<Stock>>(\"GetStocks\");\r\n        foreach (Stock stock in stocks)\r\n        {\r\n            Console.WriteLine(\"Symbol: {0} price: {1}\", stock.Symbol, stock.Price);\r\n        }\r\n    }\r\n    catch (Exception ex)\r\n    {\r\n        Console.WriteLine(\"Error invoking GetStocks: {0}\", ex.Message);\r\n    }\r\n\r\n### Client Pool\r\nThe client pool lets you call methods on the server. The client pool is made for sending only and is often used in legacy applications to boost them to real-time with 2 lines of code.\r\n\r\nFor example, if you have a half-duplex service such as a WCF you can boost it to real-time by just doing this.\r\n\r\n    var conn = ClientPool.GetInstance(\"ws://localhost:4502\",\"http://localhost\");\r\n    conn.Send(\"Hello from client pool\",\"chatmessage\",\"chat\");\r\n    \r\nAbove we send the text `Hello from client pool` to the method `ChatMessage` on the controller `Chat`. As always you can send any object that can be serialized.\r\n\r\n### Using In-Memory Storage\r\nThis feature lets you store any serializable object on the server by using simple methods on the client API's. This is useful when you need to store data between connections/pages for the client. You are responsible for cleaning up the memory your self since data written to the storage will remain there until you remove it or the server stops.\r\n\r\nWhen you use the storage you always work on a controller instance since each controller can have its own storage\r\n\r\n***Note: You can set any serializable object as value in the storage***\r\n\r\n#### Setting data on the server\r\nSet the generic type that you want to store (in this case string)\r\n\r\n    conn.Controller(\"chat\").StorageSet(\"color\",\"blue\");\r\n\r\n#### Get notifications when the data changes on the server\r\nSince the storage is per client you will only get notifications for changes in the current client.\r\n\r\n    conn.Controller(\"chat\").StorageOnSet<string>(\"color\", s => Console.WriteLine(\"Color {0} was set in storage\", s));\r\n    \r\n#### Getting data from the server\r\n\r\n    var color = conn.Controller(\"chat\").StorageGet<string>(\"color\");\r\n    Console.WriteLine(\"Got color {0} from storage\", color);\r\n\r\n#### Removing data on the server\r\n\r\n    conn.Controller(\"chat\").StorageRemove(\"color\");\r\n\r\n#### Get notifications when the data is removed on the server\r\n\r\n    conn.Controller(\"chat\").StorageOnRemove<string>(\"color\", s => Console.WriteLine(\"Color {0} was removed from storage\", s));\r\n\r\n#### Clear the storage\r\n    \r\n    conn.Controller(\"chat\").StorageClear();\r\n\r\n----------\r\n##JavaScript Client API  Guide\r\nTo get the client just get the latest package from [nuget.org/packages/xsockets.jsapi][5]\r\n\r\nThe JavaScript API supports RPC, PUB/SUB and WebRTC.\r\n\r\n###Client Setup\r\nThe JavaScript client has no dependencies, just add the `XSockets.latest.js` to your page.\r\n\r\n   &lt;script src=&quot;Scripts/XSockets.latest.min.js&quot;&gt;&lt;/script&gt;\r\n   \r\n###How to establish a connection\r\nTo get a connection just pass in the endpoint to the server.\r\n\r\n    var conn = new XSockets.WebSocket('ws://localhost:4502',['chat']);\r\n\r\nNote that the second parameter is an array of controllers to connect to. We only use one controller in this sample.\r\n\r\n###How to configure the connection\r\nYou have a few options when creating the connection, such as sub protocol, query strings and controllers.\r\n    \r\n####How to specify query string parameters\r\nYou might wanna pass in query string parameters in the connection. This is done by setting the third parameter to key-value pairs of JSON-object.\r\n\r\n    var conn = new XSockets.WebSocket('ws://localhost:4502',['chat'],{username:'steve',age:35});\r\n\r\n####How to specify controllers\r\nSince you can multiplex over several controllers on one connection you can specify the controllers to use when you create the connection. If you would like to connect to three controllers `A`, `B` and `C` you would do:\r\n\r\n    var conn = new XSockets.WebSocket('ws://localhost:4502',['a','b','c']);\r\n\r\nThe names of the controllers is not case sensitive so `A` is the same as `a`.\r\n\r\n###RPC\r\n\r\n####How to set properties on the server from the client\r\nSince we have state on all controllers in the connection and can take advantage of that we can store information server side and not send trivial things like a user name each time we want to communicate.\r\n\r\n**Server**\r\n\r\nA simple model for a chat\r\n\r\n    public class ChatModel\r\n    {\r\n        public string UserName {get;set;}\r\n        public string Text {get;set;}\r\n    }\r\n\r\nA controller where we use state to only send in text since the username is known.\r\n\r\n    public class Chat : XSocketController\r\n    {\r\n        public string UserName {get;set;}\r\n        public void ChatMessage(ChatModel message)\r\n        {\r\n            message.UserName = this.UserName;\r\n            this.InvokeToAll(message,\"chatmessage\");\r\n        }\r\n    }\r\n\r\n**Client**\r\n\r\n    conn.controller('chat').setProperty('username','David');\r\n  \r\n####How to call server methods from the client\r\n\r\n**Server**\r\n\r\nA simple model for a chat\r\n\r\n    public class ChatModel\r\n    {\r\n        public string UserName {get;set;}\r\n        public string Text {get;set;}\r\n    }\r\n\r\nA controller where we use state to only send in text since the user name is know. See `How to set properties on the server from the client`\r\n\r\n    public class Chat : XSocketController\r\n    {\r\n        public string UserName {get;set;}\r\n        public void ChatMessage(ChatModel message)\r\n        {\r\n            message.UserName = this.UserName;\r\n            this.InvokeToAll(message,\"chatmessage\");\r\n        }\r\n    }\r\n\r\n**Client**\r\n\r\nSince we already have set the property of `UserName` on the server we only need to send the `Text` property\r\n\r\n    conn.controller('chat').invoke('chatmessage',{Text:'Calling chatmessage on server and passing a part of the complex object'});\r\n \r\n####How to define methods on the client that the server can call\r\nTo define a method that the server can call from a `Controller`just add a method to the controller in JavaScript. The parameters can be complex objects.\r\n\r\nMethod name has to be lowercase in the JavaScript API. \r\nFor example:\r\n\r\n    this.Invoke('Hello from server','ChatMessage'); \r\n    \r\non the server will execute `chatmessage` on the client.\r\n\r\n**Client**\r\n\r\n    var conn = new XSockets.WebSocket('ws://localhost:4502',['chat']);\r\n    \r\n    conn.controller('chat').chatmessage = function(data){\r\n        console.log(data.UserName + \" - \" + data.Text);\r\n    };\r\n\r\n**Server**\r\n\r\nA simple model for a chat\r\n\r\n    public class ChatModel\r\n    {\r\n        public string UserName {get;set;}\r\n        public string Text {get;set;}\r\n    }\r\n  \r\nA controller where we use state to only send in text since the user name is know. See `How to set properties on the server from the client`\r\n\r\n    public class Chat : XSocketController\r\n    {\r\n        public string UserName {get;set;}\r\n        public void ChatMessage(ChatModel message)\r\n        {\r\n            message.UserName = this.UserName;\r\n            this.InvokeToAll(message,\"chatmessage\");\r\n        }\r\n    }\r\n\r\n####How to call a server side method and wait for the result\r\n\r\n**Client**\r\n\r\n    conn.controller('stockticker').invoke('getstocks').then(function(data){\r\n        console.log(data);\r\n    });\r\n\r\n**Server**\r\n\r\n    public IEnumerable<Stock> GetStocks()\r\n    {\r\n        return _stockService.GetAll();\r\n    }\r\n\r\n###PUB/SUB\r\n####How to define subscription methods on the client that the server can publish to\r\n\r\n    conn.controller('chat').subscribe('chatmessage', function(data) {\r\n        console.log(data);\r\n    });\r\n        \r\n#####How to subscribe one time\r\nIf you only want to get a message once and then unsubscribe automatically you can use `one`\r\n\r\n    conn.controller('chat').one('chatmessage', function(data){\r\n        console.log(data);\r\n    });\r\n    \r\nThis will make sure that the client unsubscribe to the topic after getting the first message.\r\n\r\n#####How to subscribe n times\r\nIf you want to get a message 1 to n times and then unsubscribe automatically you can use `many`\r\n\r\n    conn.controller('chat').many('chatmessage', 3 function(data){\r\n        console.log(data);\r\n    });\r\n\r\nThis will unsubscribe the `chatmessage` topic after getting 3 messages.    \r\n\r\n#### How to know when the subscription is ready\r\nWhen you compare PUB/SUB with RPC an obvious disadvantage with PUB/SUB is that you do not know if the server has bound the subscription when you do a publish. Therefor you can pass in an additional function to get a callback from the server when the subscription is completed.\r\n\r\nThis works similar for all subscribe methods.\r\n\r\n    subscribe(topic, fn, cb);\r\n    one(topic, fn, cb);\r\n    many(topic, n, fn, cb);\r\n\r\nwhere `fn` is called when a publish occurs and `cb` is the callback that confirms the subscription.\r\n\r\n####How to publish to server methods from the client\r\n\r\n**Client**\r\n\r\n    conn.controller(\"chat\").publish(\"chatmessage\",{Text= \"Hello people!\"});\r\n\r\n**Server**\r\n\r\n    //The server migth publish the message back to all clients subscribing\r\n    public void ChatMessage(ChatModel chatModel)\r\n    {\r\n        this.PublishToAll(chatModel, \"chatmessage\");\r\n    }\r\n\r\n###How to handle connection lifetime events\r\nThe events on connection level provide information about the socket being opened/closed. The controllers has their own lifetime events.\r\n\r\n#### OnConnected\r\n\r\n    conn.onconnected = function(){\r\n        console.log('socket connected');\r\n    };\r\n                \r\n#### OnDisconnected\r\n    \r\n    conn.ondisconnected = function(){\r\n        console.log('socket disconnected');\r\n    };\r\n    \r\n###How to handle controller lifetime events\r\nThe controller has nothing to do with the actual socket. These events tell you about the controllers you are using over your connection.\r\n\r\n#### OnOpen Event\r\n\r\n    conn.controller(\"chat\").onopen = function(ci){\r\n        console.log('opened',ci);\r\n    };\r\n\r\n#### OnClose Event\r\n    \r\n    conn.controller(\"chat\").onclose = function(ci){\r\n        console.log('closed',ci);\r\n    };\r\n\r\n### Open a controller\r\nAs soon as you start to communicate over a new controller the `OnOpen` event will fire. You actually do not need to specify the controller in the connection. As long as the controller exists on the server the `OnOpen` event will fire.\r\n\r\n### Close a controller\r\nTo close as controller (not the actual connection/socket) you just call the `Close` method on the controller instance. This will fire the `OnClose` event on the controller.\r\n\r\n    conn.controller(\"chat\").close();\r\n    \r\n###How to handle errors\r\n\r\n    conn.controller(\"chat\").onerror = function(err){\r\n        console.log(err);\r\n    };\r\n    \r\n### Using In-Memory Storage\r\nThis feature lets you store any serializable object on the server by using simple methods on the client API's. This is useful when you need to store data between connections/pages for the client. You are responsible for cleaning up the memory your self since data written to the storage will remain there until you remove it or the server stops.\r\n\r\n***Note: You can set any serializable object as value in the storage***\r\n\r\n#### Setting data on the server\r\nSet the generic type that you want to store (in this case string)\r\n\r\n    conn.controller('chat').storageSet('color','red');\r\n    \r\n#### Getting data from the server\r\n\r\n    conn.controller('chat').storageGet('color', function(data){console.log(data)});\r\n\r\n#### Removing data on the server\r\n\r\n    conn.controller('chat').storageRemove('color');\r\n\r\n#### Clear the storage\r\n    \r\n    conn.controller('chat').storageClear();\r\n    \r\n----------\r\n##Logging\r\n\r\nAs of 4.0 XSockets will use [SeriLog.NET][6] as the default logger. Since it is a plugin you can of course replace SeriLog with something else if you want to.\r\n\r\nBy default the logger will log everything in `Debug` and only `Fatal` level in `Release`.\r\n\r\nIt is very easy to set your custom SeriLogger/Configuration/Sink. Just implement the `IDefaultLogger` interface and set the configuraiton of choice. For more information about SerilLog see [SeriLog.NET][7]\r\n\r\n    //\r\n    // Sample below will write to file and console\r\n    //\r\n    \r\n    [Export(typeof(IDefaultLogger))]\r\n    public class MyLogger : IDefaultLogger\r\n    {       \r\n        public ILogger Logger\r\n        {\r\n            get\r\n            {\r\n                return new LoggerConfiguration()\r\n                    .WriteTo.ColoredConsole()\r\n                    .WriteTo.File(\"log.txt\")\r\n                    .CreateLogger();\r\n            }\r\n        }\r\n    }\r\n\r\n----------\r\n\r\n##Configuration\r\nWhen self-hosted the XSockets server will start with two endpoints loopback & machine IP (both on port 4502). For example my current machine would start the server at `ws://127.0.0.1:4502` and `ws:192.168.1.6:4502`\r\n\r\n### Custom configuration\r\nThe namespace for configuration is `XSockets.Core.Configuration`\r\n\r\nThere are two ways of creating custom configuration. \r\n\r\n#### Pass in configurations/settings to the StartServers method\r\nCreate one or more configuration classes that XSockets will implement at startup\r\nPassing configuration as a parametertop\r\n\r\nJust create the configurations needed and pass them to StartServers\r\n\r\n    //List of IConfigurationSettings\r\n    var myCustomConfigs = new List<IConfigurationSetting>();\r\n\r\n    //Add one configuration\r\n    myCustomConfigs.Add(new ConfigurationSetting(\"ws://192.74.38.15:4502\"));  \r\n\r\n    using (var server = Composable.GetExport<IXSocketServerContainer>())\r\n    {\r\n        server.StartServers(configurationSettings:myCustomConfigs);\r\n        Console.WriteLine(\"Started, hit enter to quit\");\r\n        Console.ReadLine();\r\n        server.StopServers();\r\n    }\r\n\r\nNote: you can of course pass in several configuration.\r\n\r\n#### Configuration as a plugin\r\n\r\nJust inherit the `XSockets.Core.Configuration.ConfigurationSetting` class and implement your configuration. XSockets will find and and use these custom configurations.\r\n\r\n    public class MyTestConfig : ConfigurationSetting\r\n    {\r\n        public MyTestConfig() : base(\"ws://195.74.38.15:4502\")\r\n        {\r\n        }\r\n    }\r\n    \r\nNow there is no need to pass in anything to the StartServers method, it will find the configuration above. When you use this technique the server will not create the default configuration. If you want to have for example 127.0.0.1:4502 as a configuration you have to add that as a plugin as well.\r\n\r\n    container.Start();\r\n    \r\n### What can I configure\r\n\r\nThe `Start` method has a number of options, and then the `ConfigurationSetting` class itself has a number of options.\r\n\r\n#### Method signature of Start\r\n\r\n    void Start(bool useLoopback = true, bool withInterceptors = true, IList<IConfigurationSetting> configurationSettings = null);\r\n    \r\n*Note: Interceptors are by default enabled!\r\n\r\n#### DNS Configuration\r\nOne of the most common questions about configuration is how to enable DNS configuration.\r\n\r\n##### Public Endpoint\r\nLet's say that you want to connect (client <-> server) to ws://chucknorris.com:4502 the configuration for that could look like\r\n\r\n    public class ChuckNorrisConfig : ConfigurationSetting\r\n    {\r\n        public ChuckNorrisConfig() : base(new Uri(\"ws://chucknorris.com:4502\")) { }\r\n    }\r\n    \r\n**Note: This setup will create an endpoint based on the DNS provided. Note that port 4502 have to be open.\r\n\r\n##### Public & Private Endpoint\r\nLet's say that you want to connect (client <-> firewall <-> server) to ws://chucknorris.com:4502, but the public endpoint is represented by a firewall. Your firewall will then forward the connection to our servers private IP address (for example 192.168.1.7).\r\n\r\n    public class ChuckNorrisConfig : ConfigurationSetting\r\n    {\r\n        public ChuckNorrisConfig() : base(new Uri(\"ws://chucknorris.com:4502\"), new Uri(\"ws://192.168.1.7:4510\")) { }\r\n    }\r\n\r\n**Note: This setup requires that you forward traffic in your firewall to `192.168.1.7:4510`\r\n\r\n##### SSL/TLS\r\nTo get WSS you have to set the endpoint to be ´wss´ instead of ws, and you will also specify you certificate. This can either be done by setting `CertificateLocation` and `CertificateSubjectDistinguishedName` (as in the sample) or load the certificate from disk.\r\n\r\n    //Sample 1 - Certificate from store\r\n    public class ChuckNorrisConfig : ConfigurationSetting\r\n    {\r\n        public ChuckNorrisConfig() : base(new Uri(\"wss://chucknorris.com:4502\"))\r\n        {\r\n            this.CertificateLocation = StoreLocation.LocalMachine;\r\n            this.CertificateSubjectDistinguishedName = \"cn=chucknorris.com\";\r\n        }\r\n    }\r\n\r\n    //Sample 2 - X509Certificate2\r\n    public class ChuckNorrisConfig : ConfigurationSetting\r\n    {\r\n        public ChuckNorrisConfig() : base(new Uri(\"wss://chucknorris.com:4502\"))\r\n        {\r\n            this.Certificate = new X509Certificate2(\"file.name\", \"password\");\r\n        }\r\n    }\r\n    \r\n----------\r\n##Hosting\r\n###OWIN\r\nTo host XSockets in OWIN is easy and also let you access the HttpContext and the authenticated user (if any).\r\n\r\n**Install**\r\n`PM> Install-Package XSockets.Owin.Host`\r\n\r\nRegister XSockets in Owin IAppBuilder\r\n\r\n    public class Startup\r\n    {\r\n        public void Configuration(IAppBuilder app)\r\n        {\r\n            app.UseXSockets(true);\r\n        }\r\n    }\r\n    \r\n###Windows Service\r\nUse the XSockets.Windows.Service package from chocolatey to install XSockets as a windows service. You can then add you custom configurations, controller, interceptors etc into the location of the service and restart it to make it find you custom code.\r\n\r\nNote that by default you will get the `Generic` controller as well as the `WebRTC` controller named \"Broker\" installed with the service.\r\n\r\n\r\n**Install:**\r\n\r\n 1. If not done install chocolatey (http://chocolatey.org/)\r\n 2. Open up the Command Prompt and type cinst XSockets.Windows.Service\r\n    \r\n###Console Application\r\nCreate a new ConsoleApplication and install the package XSockets. This will output some sample code for getting the server started.\r\n\r\n**Install:**\r\n`PM> Install-package XSockets`\r\n\r\n    using (var container = XSockets.Plugin.Framework.Composable.GetExport<IXSocketServerContainer>())\r\n    {\r\n        container.Start();\r\n        foreach(var server in container.Servers)\r\n        {\r\n            Console.WriteLine(server.ConfigurationSetting.Endpoint);\r\n        }\r\n        Console.WriteLine(\"Server started, hit enter to quit\");\r\n        Console.ReadLine();\r\n    }\r\n    \r\n###Azure\r\nYou will have to have the Azure SDK installed.\r\n\r\n 1. Create a Windows Azure Worker Role\r\n 2. Open the Package Manager Console\r\n 3. Install the XSockets.Server using\r\n    \r\n        PM -> Install-Package XSockets.Server\r\n\r\n 4. Open the Property Page for the Worker Role. \r\n    You will find it in the /Roles/ foler of your WorkerRole Project.\r\n 5. Add a TCP endpoint using the Endpoints Tab.\r\n    - Name the Endpoint i.e 'MyEndoint'\r\n    - Set the type to input\r\n    - Set the protocol, to TCP\r\n    - Define the Public & Private port that you want to use.\r\n\r\n 6. Add a configuration setting using the Settings tab, we need to define the EndPoint Uri here.\r\n    - Set a name on the setting i.e 'MyUri'\r\n    - Set the type to string\r\n    - Set the value to i.e `ws://127.0.0.1:4510` (this depends on your enviorment).\r\n\r\n 7. Add the following code the the OnStart() method of your WorkerRole (WorkerRole.cs)\r\n\r\n        var container = XSockets.Plugin.Framework.Composable.GetExport<IXSocketServerContainer>();\r\n        // Create a Custom Configuration based on what we have defined using property pages.\r\n        var myCustomConfig = new List<IConfigurationSetting>();\r\n        var config = new ConfigurationSetting(new Uri(RoleEnvironment.GetConfigurationSettingValue(\"MyUri\")))\r\n        {\r\n            Endpoint = RoleEnvironment.CurrentRoleInstance.InstanceEndpoints.FirstOrDefault(n => n.Key.Equals(\"MyEndpoint\"))\r\n                .Value.IPEndpoint\r\n        };\r\n        myCustomConfig.Add(config);\r\n        container.Start(configurationSetting: myCustomConfig);\r\n\r\n 8. Compile and run\r\n\r\nNow, Try connect to the Generic Controller using the following piece of JavaScript Code\r\n\r\n    var ws = new XSockets.WebSocket('ws://127.0.0.1:4510',['generic']);\r\n    \r\n###Amazon\r\n\r\n    TODO\r\n\r\n----------\r\n## Fallback\r\nTo use the fallback in XSockets you have to have OWIN, .NET 4.5 and WebAPI.\r\n\r\n    TODO (will be included in next pre-release)\r\n    \r\n----------\r\n\r\n##Performance & Scaling\r\n    \r\n    TODO\r\n    \r\n### Performance Counters\r\n\r\n    TODO\r\n    \r\n### Cluster\r\nIn the `Enterprise` version you can scaleout XSockets over `n` servers. By default XSockets offers scaleout over sockets, this means that there will be no bottle neck like in other solutions that scaleout over MSSQL etc.\r\n\r\nYou can add several servers to the scaleout, this is done by requesting the `IXSocketsScaleOut` plugin from the `plugin framework` and then just add a server using the method `AddScaleOut`.\r\n\r\nNote that this will scale in one direction from this server to `ws://127.0.0.1:4503`. So to get scaling both ways you just add this servers location to the server on `4503`\r\n\r\n    Composable.GetExport<IXSocketsScaleOut>().AddScaleOut(\"ws://127.0.0.1\", 4503);\r\n    \r\n#### Implementing Custom ScaleOut\r\nIf you rather scaleout over SQL, Redis etc you can write a custom scaleout by implementing the ´IXSocketsScaleOut´ interface\r\n\r\n    TODO\r\n    \r\n### Loadbalacing\r\n----------\r\n\r\n##FAQ\r\n\r\n    TODO\r\n    \r\n----------\r\n\r\n##Security\t\r\nXSockets.NET does not provide any features for authenticating users. Instead, you integrate the XSockets:NET features into the existing authentication structure for an application. You authenticate users as you would normally in your application, and work with the results of the authentication in your XSockets.NET code. For example, you might authenticate your users with ASP.NET forms authentication, and then in your `Controller`, enforce which users or roles are authorized to call a method.\r\n\r\nXSockets provides the Authorize attribute to specify which users have access to a `controller` or `method`. You apply the Authorize attribute to either a `controller` or particular `methods` in a `controller`. Without the Authorize attribute, all public methods on the controller are available to a client that is connected to the controller. \r\n\r\nIf you want to allow unrestrcited access on some methods you can add the `AllowAnonymous` attribute the these methods.\r\n\r\nMore information about attributes and methods below\r\n\r\n### Authorize Attribute\r\n\r\nThis attribute can be set on Controller or Method level. If set at controller level all action methods that do not have the AllowAnonymous attribute will require authentication.\r\n\r\nThe authorize attribute can take Roles and Users but if using that you will have to implement your own authentication by overriding OnAuthorization(AuthorizeAttribute authorizeAttribute)\r\n\r\n### AllowAnonymous Attribute\r\n\r\nThis attribute can be set on action methods and will then allow anonymous access.\r\n\r\n### Get FormsAuthentication Ticket\r\n\r\nWhen you have custom authentication you can get the FormsAuthenticationTicket from this method.\r\n\r\n    var ticket = GetFormsAuthenticationTicket();\r\n\r\n**Note: If you do not pass in a cookiename .ASPXAUTH will be used.**\r\n\r\n**Important: If you have separate project you will have to use the same origin to be able to get cookies and also use machine-key in the config to be able to get the AuthCookie.**\r\n***See*** [machinekey compability mode][8] ***if you are using different framework versions in the projects.***\r\n\r\n### Write a custom AuthenticationPipeline\r\nWhen the socket is connected and the handshake is completed the `AuthenticationPipeline` will be called. By default the pipeline will look for a FormsAuthenticationTicket, but you can override this pipline by just implementing a interface `XSockets.Core.Common.Socket.IXSocketAuthenticationPipeline`\r\n\r\nThere can only be one pipeline so even if you implement several pipelines only one wil be used.\r\n\r\n    [Export(typeof(IXSocketAuthenticationPipeline))]\r\n    public class MyAuthenticationPipeline : IXSocketAuthenticationPipeline\r\n    {\r\n        public IPrincipal GetPrincipal(IXSocketProtocol protocol)\r\n        {            \r\n            if (protocol.ConnectionContext.User == null)\r\n            {\r\n                //creating a fake super user ;)\r\n                var roles = new string[]{\"superman\",\"hulk\"};\r\n                var userIdentity = new GenericIdentity(\"David\");\r\n                protocol.ConnectionContext.User = new GenericPrincipal(userIdentity, roles);\r\n            }            \r\n\r\n            return protocol.ConnectionContext.User;\r\n        }\r\n    }\r\n\r\n### How to override the OnAuthorization method\r\nThe `OnAuthorization` method is called for every method on a controller that has authentication. The attribute for the method (or controller) is passed in and we check that \r\n\r\n 1. That the user is authenticated\r\n 2. If the user name is required we verify a match\r\n 3. If user name was not required or did not match we check roles\r\n\r\n        public virtual bool OnAuthorization(IAuthorizeAttribute authorizeAttribute)\r\n        {\r\n            try\r\n            {\r\n                var user = this.ProtocolInstance.ConnectionContext.User;\r\n                if (user.Identity.IsAuthenticated)\r\n                {\r\n                    if (!string.IsNullOrEmpty(authorizeAttribute.Roles) || !string.IsNullOrEmpty(authorizeAttribute.Users))\r\n                    {                    \r\n                        if (authorizeAttribute.Users.Split(',').Contains(user.Identity.Name)){\r\n                            return true;\r\n                        }\r\n                        return authorizeAttribute.Roles.Split(',').Any(user.IsInRole);      \r\n                    }\r\n                    return true;\r\n                }\r\n                return false;\r\n            }\r\n            catch\r\n            {\r\n                return false;\r\n            }\r\n        }\r\n\r\n**Example**\r\nBased on the `Write a custom AuthenticationPipeline` where we added the username `Hero` and the roles `hulk`, `superman` we have the following scenario\r\n\r\n    [Authorize()] //would be valid since we have a authorized `fake` user\r\n\r\n    [Authorize(Users = \"David\")] //would be valid\r\n\r\n    [Authorize(Roles = \"batman,robin\")] //would be invalid\r\n    \r\n    [Authorize(Roles = \"batman,hulk\")] //would be valid\r\n    \r\n### How to know when authorization fails\r\nEvery time a method on a controller needs authorization the `OnAuthorization` method is called (which was overridden in previous sample).\r\n\r\nWhen the `OnAuthorization` returns false the `OnAuthorizationFailed` event is fired.\r\n\r\n    //Constructor\r\n    public Chat()\r\n    {\r\n        this.OnAuthorizationFailed += Chat_OnAuthorizationFailed;\r\n    }\r\n\r\n    void Chat_OnAuthorizationFailed(object sender, OnAuthorizationFailedArgs e)\r\n    {\r\n        Console.WriteLine(\"Auth Failed: {0},{1}\", e.Controller, e.MethodName); \r\n    }\r\n\r\nThe `OnAuthorizationFailedArgs` contains information about the controller and the method being called. Information about the user that called the method can be accessed from `this.ProtocolInstance.ConnectionContext.User`\r\n\r\n----------\r\n\r\n## The Plugin Framework\r\nThe plugin framework is inspired by MEF (Managed Extensibility Framework). MEF is awesome, but we wrote our own plugin framework to be able to run everywhere and also to avoid any dependencies. We did not copy stuff from MEF that we did not need and we added some extra features the we thought would be nice to have.\r\n\r\n### Quick Start\r\nA very basic example based on a MEF sample that you can find at [http://www.amazedsaint.com/2010/06/mef-or-managed-extensibility-framework.html][9]\r\n\r\nFirst of all... Open up the `Package Manager Console` (Tools->Library Package Manager->Package Manager Console) below called PMC. Install by typing `Install-Package XSockets.Plugin.Framework` into the PMC and hit enter.\r\n\r\nThe plugin framework has `no dependencies` and can be used in any project without using the rest of XSockets.NET\r\n\r\n#### Introduction\r\nJust like in MEF it is all about `Exports` and `Imports`. In `XSockets.Plugin.Framework` you can choose to export on interface level which means that you only have to implement the interface to get `Exports` and `Imports` to work. You actually dont event need the `Exports/Imports` since the framework allows you to register exported types at runtime, but the default scenario is to use the attributes.\r\n\r\n#### Define Interfaces\r\nSo lets build a zoo (just like the example in the link above).\r\n\r\nFirst of all we need a `IAnimal` interface for our animals. We also decorate the class with the `Export` attribute\r\n\r\n    [Export(typeof(IAnimal))] \r\n    public interface IAnimal\r\n    {\r\n        void Eat();\r\n    }\r\n\r\nWe also need A `IZoo` interface, it has an `IEnumerable of IAnimal`. Just like the IAnimal interface the `IZoo` has the `Export` attribute. Also note that we use the `ÌmportMany` attribute to get all `Exports` of `IAnimal`\r\n\r\n    [Export(typeof(IZoo))]\r\n    public interface IZoo\r\n    {\r\n        [ImportMany(typeof(IAnimal))]\r\n        IEnumerable<IAnimal> Animals { get; set; }\r\n    }\r\n\r\n#### Classes Implementing Interfaces\r\nFirst we create `Lion` and `Rabbit` classes and implement the `IAnimal` interface so that the classes become modules/plugins\r\n\r\nNote that we do not have to specify anything on the classes since the interfaces has the `Exports` and `Imports`\r\n\r\n    public class Lion : IAnimal\r\n    {\r\n        public Lion()\r\n        {\r\n            Console.WriteLine(\"Grr.. Lion got created\");\r\n        } \r\n        public void Eat()\r\n        {\r\n            Console.WriteLine(\"Grr.. Lion eating meat\");\r\n        }\r\n    }\r\n    \r\n    public class Rabbit : IAnimal\r\n    {\r\n        public Rabbit()\r\n        {\r\n            Console.WriteLine(\"Meeep.. Rabbit got created\");\r\n        } \r\n        public void Eat()\r\n        {\r\n            Console.WriteLine(\"Meeep.. Rabbit eating carrot\");\r\n        }\r\n    }\r\n\r\nNow we just need a `Zoo` to keep the `Animals` in.\r\n\r\n    public class Zoo : IZoo\r\n    {\r\n        public IEnumerable<IAnimal> Animals { get; set; }\r\n    } \r\n\r\n\r\n####Using the Plugin Framework\r\n\r\nNote that the the interfaces decides how the classes should behave regarding Exports/Imports\r\n\r\n    class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            //Get a single instance of Zoo... We only expect one zoo to exist\r\n            var zoo = Composable.GetExport<IZoo>();\r\n            //List the animals found in the zoo\r\n            foreach (var animal in zoo.Animals)\r\n                animal.Eat();\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n\r\nThe output from the program would be...\r\n\r\n    Grr.. Lion got created\r\n    Meeep.. Rabbit got created\r\n    Grr.. Lion eating meat\r\n    Meeep.. Rabbit eating carrot\r\n\r\n### Handling Exceptions\r\nYou can use the `Composable.AddErrorAction` to get information about any exceptions taht occurs inside of the plugin framework. If you add several `actions` they will all be called when/if an exception is thrown.\r\n\r\n    Composable.AddErrorAction(ex => Console.WriteLine(\"First ErrorAction: {0}\", ex.Message));\r\n    Composable.AddErrorAction(ex => Console.WriteLine(\"Second ErrorAction: {0}\", ex.Message));\r\n\r\n### Understanding the concept & add custom plugins\r\nThe concept of the plugin framework is all about exporting and importing interfaces. We believe that all you need at compile time is the knowledge of the interface. The framework should load all exported and imported types at startup (runtime).\r\n\r\nBy having that kind of architecture we get very decoupled systems. We can replace current functionality (or add new functionality) by just implementing an interface. We can even do so at runtime if we want to.\r\n\r\n#### Config\r\nBy default the plugin framework will search for plugins at the location where the executable (or eqvivalent) is running. The plugin will be loaded at first usage of the plugin framework, but you can add assemblies (or paths to search) at runtime.\r\n\r\nThe framework will by defualt load assemblies (*.dll) and executables (*.exe) but you can also add your own filters to the configuration.\r\n\r\n#### Exports & Imports\r\nBy setting the Export attribute on a interface or class you tell the framework that you want to export this. And not surprising you import stuff by using ImportOne or ImportMany.\r\n\r\n#### Attributes\r\nTo explain the concept easily we will create a few simple classes and decorate them.\r\n\r\n##### ImportOne\r\n\r\n    TODO:\r\n\r\n##### ImportMany\r\n\r\n    TODO:\r\n\r\n##### ImportingConstructor\r\n\r\n    TODO:\r\n\r\n##### Export\r\nBy adding the Export attribute to an interface (or a class) the plugin framework will detect and use the instance as a module/plugin. You always have to provide the type being exported when using the Export attribute, but there other setting as well\r\n\r\n###### InstancePolicy\r\n\r\nSets the lifecycle for the export. Using InstancePolicy.Shared will create a singleton of the export and only one instance will live in the app-domain. The default lifecycle is InstancePolicy.NewInstance and you will not need to set this option.\r\n\r\n###### Rewritable\r\n\r\nBy default the Rewritable option is set to Rewritable.No, but if you set it to Rewritable.Yes your module/plugin can be overridden if someone implements the interface on another class. That framework will then throw your version away and use the new module/plugin.\r\n\r\n##### MetaDataExport\r\n\r\n    TODO:\r\n\r\n#### Adding functionality at runtime (re-compose)\r\nSometimes you might want to add both new interfaces and plugins at runtime, below is a simple example of howto do so.\r\n\r\nLets say that we have an interface IAnimal located in a separate assembly (project)\r\n\r\n    /// <summary>\r\n    /// This interface is not exported and \r\n    /// will not be available in the XSockets.Plugin.Framework (by default)\r\n    /// \r\n    /// All interfaces that you are planning on using have to be known a compile time\r\n    /// </summary>\r\n    public interface IAnimal\r\n    {\r\n        void Says();\r\n    }\r\n    \r\nIn another assembly (not referenced) we have a class Lion that implements the IAnimal interface\r\n\r\n    /// <summary>\r\n    /// This class does not have to be know at compile time\r\n    /// It might be added later and added to the XSockets.Plugin.Framework\r\n    /// It can be used since it has an interface!\r\n    /// </summary>\r\n    public class Lion : IAnimal\r\n    {\r\n        public void Says() { Console.WriteLine(\"Grrr\"); }\r\n    }\r\n\r\nIn our XSockets solution we only reference the project/assembly with the interface IAnimal. This interface is not exported by default, so we tell the plugin framework (at runtime) to also use IAnimal as an export.\r\n\r\nThat is done by\r\n\r\n    Composable.RegisterExport<IAnimal>();\r\n\r\nBut the Lion class is unknown so we add the assembly with Lion\r\n\r\n    Composable.LoadAssembly(@\"C:\\temp\\someassembly.dll\");\r\n\r\nThen we tell the plugin framework to \"recompose\" = satisfy all imports/exports\r\n\r\n    Composable.ReCompose();\r\n\r\nWe can now get all instances of IAnimal using GetExport or GetExports...\r\n\r\n##### Two different approaches listed below!\r\n\r\n**Approach 1**\r\n\r\nHere the classes implementing IAnimal is known in the current solution so we do not have to load any assemblies.\r\n\r\n    //Lets make the plugin framework aware of IAnimal\r\n    Composable.RegisterExport<IAnimal>();\r\n    Composable.ReCompose();\r\n    foreach (var animal in Composable.GetExports<IAnimal>())\r\n    {\r\n        animal.Says();\r\n    }\r\n    \r\n**Approach 2**\r\n\r\nHere there are implementations of IAnimal in a assembly not yet loaded.\r\n\r\n    Composable.RegisterExport<IAnimal>();\r\n    Composable.LoadAssembly(@\"C:\\temp\\PluginDemo.dll\");\r\n    //OR... load many assemblies from a folder and possibly subfolders\r\n    //Composable.AddLocation(@\"c:\\temp\\\", SearchOption.AllDirectories);\r\n    Composable.ReCompose();\r\n    foreach (var animal in Composable.GetExports<IAnimal>())\r\n    {\r\n        animal.Says();\r\n    }\r\n\r\n----------\r\n## Packages\r\nDescribes all available packages on [Nuget][10] and [Chocolatey][11]\r\n###Chocolatey Packages\r\n####XSockets.Windows.Service\r\n\r\nYou can view [this video][12] on how to install our Windows Service from Chocolatey\r\n\r\n###Nuget Packages\r\n####XSockets\r\n\r\nThis package will behave in different ways depending on where you install it. If you do not know what to do, use this package.\r\n\r\nThis package will install ItemTemplates for XSockets.NET 4 into Visual Studio.\r\n\r\n - XSockets.Server\r\n - XSockets.Core\r\n - XSockets.Plugin.Framework\r\n - XSockets.Fallback (if installed into a web-application with .NET 4.5+)\r\n\r\n####XSockets.Core\r\n\r\nThis package contains the functionality to write custom real-time controllers. Install this package into a class-library if you want to develop custom server-side functionality\r\n\r\nDependencies: - XSockets.Plugin.Framework\r\n\r\n####XSockets.OWIN.Host\r\n\r\nThis package contains the functionality to host XSockets inside of OWIN.\r\n\r\nDependencies: - XSockets.Server\r\n\r\n####XSockets.Plugin.Framework\r\n\r\nA package for building modular applications in a blink.\r\n\r\nDependencies: none\r\n\r\n####XSockets.Fallback\r\n\r\nA fallback from websocket to longpolling via WebAPI if installed into .NET 4.5+\r\n\r\nDependencies: - none\r\n\r\n####XSockets.Client\r\n\r\nProvides a socket client for connecting to a XSockets.NET server.\r\nSupported platforms are:\r\n\r\n - Mono\r\n - .NET 4.0+\r\n - iOS (MonoTouch)\r\n - Android (MonoDroid)\r\n - NETMF 4.2, 4.3\r\n\r\nDependencies: - XSockets.Core\r\n\r\n####XSockets.JsApi\r\n\r\nProvides a JavaScript API for communication with text/binary messages to a XSockets server with a publish/subscribe pattern\r\n\r\nDependencies: none\r\n\r\n####XSockets.Sample.Stockticker\r\n\r\nA sample project copied from the SignalR stockticker but rewritten for XSockets so that you can compare it easier with SignalR.\r\n\r\nDependencies: XSockets\r\n\r\n####XSockets.Sample.WebRTC\r\n\r\nA sample project that will provide a sample of a multi-video chat within the browser. Source code found at: https://github.com/XSockets/WebRTC\r\n\r\nDependencies: XSockets\r\n\r\n----------\r\n\r\n#Instructions for Beta Testers\r\nThank you for signing up to be a tester of XSockets 4.0 beta.\r\n\r\nWe have been working very hard on this release and we tried to add/fix all the stuff the community have asked for or pointed out. \r\n\r\n## Some of the new features in 4.0\r\nYou have probably been reading about most of them since you signed up for this beta, but a unordered list with the biggest changes are:\r\n\r\n - Support for RPC (as a complement or replacement for pub/sub)\r\n - Multiplexing over several controllers on one connection\r\n - Owin Support\r\n - Clients for iOS (MonoTouch), Android (MonoDroid), C# that all use full-duplex/bi-directional communication\r\n - Synchron communication so that you can wait for the result from a controller method\r\n - IMessage replace ITextArgs and IBinaryArgs, much easier and better binary support\r\n - Binary support to any method in a controller (just like any object)\r\n - You can pass meta data with binary data to get information about files etc being sent\r\n - Hearbeat helpers for sending control-frames (pings/pongs)\r\n - AuthenticationPipline, a new plugin that you can use to set the IPrincipal of the ConnectionContext\r\n - Easier to create custom protocols for connecting InternetOfThings etc\r\n - Enterprise: scaling, loadbalancing\r\n\r\n##Setting up the local nuget repository\r\n 1. If you do not have a local nuget repository [follow this guide][13]\r\n 2. Unzip the file attached in your email\r\n 3. Copy all folders into the root of your local nuget repository created in step 1\r\n\r\n##Using the XSockets pre-release packages\r\nBy default pre-release packages are hidden so you will not get any help from the package manager console. You will have to spell the names correctly and also add `-IncludePrerelease`\r\n\r\nExample: `PM> Install-Package XSockets -IncludePrerelease`\r\n\r\nIf you use the graphical tool for managing nuget packages you will need to change the drop down from ´stable only´ to `include pre-release`\r\n\r\n##Documentation for Beta\r\nWe are working on a new site and will add the docs in a better format as soon as we have it online (be patient).\r\n\r\n##Feedback\r\nIf you are a experienced XSockets user you will see many changes and new features. The documentation covers almost all the new things, and we are adding stuff to the docs rapidly.\r\n\r\nWe appreciate all feedback yo can give (good and bad). So just try it and have fun! \r\nAnd if you break it, we love it so that we can improve!\r\n\r\nRegards\r\nTeam XSockets.NET\r\n\r\n----------\r\n\r\n\r\n  [1]: http://xsockets.github.io/XSockets.NET-4.0/\r\n  [2]: http://xsockets.net/$2/file/xsocketscommunication-1.png\r\n  [3]: http://msdn.microsoft.com/en-us/library/system.web.configuration.machinekeysection.compatibilitymode%28v=vs.110%29.aspx\r\n  [4]: http://nuget.org/packages/xsockets.client\r\n  [5]: http://nuget.org/packages/xsockets.jsapi\r\n  [6]: http://serilog.net/\r\n  [7]: http://serilog.net\r\n  [8]: http://msdn.microsoft.com/en-us/library/system.web.configuration.machinekeysection.compatibilitymode%28v=vs.110%29.aspx\r\n  [9]: http://www.amazedsaint.com/2010/06/mef-or-managed-extensibility-framework.html\r\n  [10]: http://nuget.org\r\n  [11]: http://chocolatey.org\r\n  [12]: https://www.youtube.com/watch?v=vDYKdB9Vuos\r\n  [13]: http://docs.nuget.org/docs/creating-packages/hosting-your-own-nuget-feeds","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}